using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Resources;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media.Imaging;
using DataAccess.Models;
using Emgu.CV;
using Emgu.CV.Features2D;
using Emgu.CV.Structure;
using Emgu.CV.Util;

namespace VKR.Utils.ImageAnalyzis;

public class ImageAnalyzer : IImageAnalyzer
{
    //private string runPythonScript()
    //{
    //int number = 5;
    //ScriptEngine engine = Python.CreateEngine();

    //ICollection<string> searchPaths = engine.GetSearchPaths();
    //searchPaths.Add(@"Utils\ImageAnalyzis\venv\Lib");
    //engine.SetSearchPaths(searchPaths);

    //ScriptScope scope = engine.CreateScope();
    //engine.ExecuteFile("Utils\\ImageAnalyzis\\Test.py", scope);

    //int y = 22;
    //dynamic x = scope.GetVariable("x");
    //dynamic z = scope.GetVariable("z");
    //Console.WriteLine($"{x} + {y} = {z}");

    //dynamic square = scope.GetVariable("square");
    //// Вызываем функцию и получаем результат
    //dynamic result = square(number);

    //////////////

    //ProcessStartInfo start = new ProcessStartInfo();
    //start.FileName = @"C:\Users\Даня\AppData\Local\Programs\Python\Python37\python.exe";
    //start.Arguments = @"Utils\ImageAnalyzis\Test.py";
    //start.UseShellExecute = false;// Do not use OS shell
    //start.CreateNoWindow = true; // We don't need new window
    //start.RedirectStandardOutput = true;// Any output, generated by application will be redirected back
    //start.RedirectStandardError = true; // Any error in standard output will be redirected back (for example exceptions)
    //using (Process process = Process.Start(start))
    //{
    //    using (StreamReader reader = process.StandardOutput)
    //    {
    //        string stderr = process.StandardError.ReadToEnd(); // Here are the exceptions from our Python script
    //        string result = reader.ReadToEnd(); // Here is the result of StdOut(for example: print "test")
    //        return result;
    //    }
    //}
    //}

    public Result RunAnalysis(string pathToOrig, List<CounterfeitPath> counterfeitPaths, double percentOfSimilarity, User user)
    {
        string anRes = "";
        string resPath = "";
        double matchTime = 0;
        double score = 0.02;
        double tempTime = 0;
        for (int i = 0; i < counterfeitPaths.Count; i++)
        {
            AnalyzeImage(ref pathToOrig, counterfeitPaths[i].ImagePath, out resPath, out tempTime, out score, percentOfSimilarity);
            matchTime += tempTime;
            if(score > percentOfSimilarity)
            {
                anRes = "Фальсификат обнаружен: " + counterfeitPaths[i].Counterfeit.Name;
                break;
            }
            else
            {
                anRes = "Фальсификат не обнаружен";
            }
        }

        var res = CreateResult(pathToOrig, resPath, anRes, user, matchTime, score);
        return res;
    }

    private void AnalyzeImage(ref string pathToOrig, string pathToCounterfeit, out string pathToResult, out double matchTime, out double score, double percentOfSimilarity)
    {
        string pathToBase = Directory.GetCurrentDirectory();
        string pathToCounterfeits = @"..\..\..\resources\counterfeits\";
        string combinedPath = Path.Combine(pathToBase, pathToCounterfeits, pathToCounterfeit);
        Mat origMat = CvInvoke.Imread(pathToOrig, Emgu.CV.CvEnum.ImreadModes.AnyColor);
        Mat counterfeitMat = CvInvoke.Imread(combinedPath, Emgu.CV.CvEnum.ImreadModes.AnyColor);
        Mat resMat = SIFTAlgorithm.Draw(origMat, counterfeitMat, out matchTime, out score);

        //Image<Bgr, Byte> OrigImage = origMat.ToImage<Bgr, Byte>();
        //Image<Bgr, Byte> ResultImage = resMat.ToImage<Bgr, Byte>();
        pathToResult = "";
        if (score > percentOfSimilarity)
        {
            var date = DateTime.Now.ToString("dd.mm.yyyy_hh.mm.ss");
            var filename = "orig_" + date + ".jpg";
            pathToOrig = filename;
            origMat.Save(@"..\..\..\resources\origImages\" + pathToOrig);

            filename = "res_" + date + ".jpg";
            pathToResult = filename;
            resMat.Save(@"..\..\..\resources\resImages\" + pathToResult);
            
            Image origImage = new Image();
            var uriSource = new Uri(@"/VKR;component/resources/origImages/" + pathToOrig, UriKind.Relative);
            origImage.Source = new BitmapImage(uriSource);

            IResourceWriter writer = new ResourceWriter(@"..\..\..\resources\origImages\" + pathToOrig);
            writer.AddResource(@"..\..\..\resources\origImages\" + pathToOrig, origImage);
            writer.Close();

            Image resImage = new Image();
            uriSource = new Uri(@"/VKR;component/resources/resImages/" + pathToResult, UriKind.Relative);
            resImage.Source = new BitmapImage(uriSource);

            writer = new ResourceWriter(@"..\..\..\resources\resImages\" + pathToResult);
            writer.AddResource(@"..\..\..\resources\resImages\" + pathToResult, resImage);
            writer.Close();
        }
    }

    private Result CreateResult(string pathToOrig, string pathToRes, string anRes, User user, double time, double score)
    {
        var tempOrigPath = new OriginalPath
        {
            Path = pathToOrig,
        };

        var tempResPath = new ResultPath
        {
            Init = tempOrigPath,
            Path = pathToRes,
        };

        var result = new Result
        {
            Date = DateTime.Now.ToString(),
            User = user,
            AnRes = anRes,
            Time = time,
            PercentOfSimilarity = score,
            OrigPath = tempOrigPath,
            ResPath = tempResPath,
        };
        return result;
    }
}